import { db } from '../../firebase';
import { 
  doc, 
  getDoc, 
  setDoc, 
  collection, 
  query, 
  where, 
  getDocs, 
  orderBy, 
  limit, 
  Timestamp,
  updateDoc,
  increment,
  arrayUnion
} from 'firebase/firestore';

export class transferService {
  static ROLES = {
    BATSMAN: 'batsman',
    BOWLER: 'bowler',
    ALLROUNDER: 'allrounder',
    WICKETKEEPER: 'wicketkeeper'
  };
  
  static TEAM_LIMITS = {
    [this.ROLES.BATSMAN]: 4,
    [this.ROLES.BOWLER]: 4,
    [this.ROLES.ALLROUNDER]: 2,
    [this.ROLES.WICKETKEEPER]: 1
  };

  
  // Get active tournament
static async getActiveTournament() {
  try {
    console.log("Getting active tournament...");
    const tournamentsRef = collection(db, 'tournaments');
    
    // Query for tournaments with status 'active'
    const q = query(tournamentsRef, where('status', '==', 'active'), limit(1));
    const snapshot = await getDocs(q);
    
    if (snapshot.empty) {
      console.log("No tournament with 'active' status found");
      // Fallback to getting the most recent tournament
      const allQuery = query(tournamentsRef, orderBy('createdAt', 'desc'), limit(1));
      const allSnapshot = await getDocs(allQuery);
      
      if (allSnapshot.empty) {
        console.log("No tournaments found at all");
        return null;
      }
      
      const tournamentData = allSnapshot.docs[0].data();
      const tournamentId = allSnapshot.docs[0].id;
      console.log(`Found most recent tournament: ${tournamentId}`);
      
      return {
        id: tournamentId,
        ...tournamentData
      };
    }
    
    const tournamentData = snapshot.docs[0].data();
    const tournamentId = snapshot.docs[0].id;
    console.log(`Found active tournament: ${tournamentId}`);
    
    return {
      id: tournamentId,
      ...tournamentData
    };
  } catch (error) {
    console.error('Error getting active tournament:', error);
    throw error;
  }
}

// Replace or update your isTransferWindowActive function with this implementation
static async isTransferWindowActive() {
  try {
    const tournament = await this.getActiveTournament();
    
    if (!tournament) {
      console.log("No active tournament found");
      return { isActive: false, window: null };
    }
    
    // If tournament itself is completed, no windows should be active
    if (tournament.status === "completed") {
      console.log("Tournament is completed, no active windows");
      return { isActive: false, window: null };
    }
    
    const transferWindows = tournament.transferWindows || [];
    
    // First look for a window explicitly marked as active
    for (const window of transferWindows) {
      if (window.status === "active") {
        // Format dates for return
        const startDate = typeof window.startDate === 'object' && window.startDate.toDate ? 
                        window.startDate.toDate() : new Date(window.startDate);
        const endDate = typeof window.endDate === 'object' && window.endDate.toDate ? 
                      window.endDate.toDate() : new Date(window.endDate);
        
        // Log for debugging
        console.log(`Found explicitly active window: Week ${window.weekNumber}`);
        
        return { 
          isActive: true, 
          window: {
            ...window,
            startDate,
            endDate
          }
        };
      }
    }
    
    // No explicitly active window, check dates
    const now = new Date();
    
    for (const window of transferWindows) {
      // Skip completed windows
      if (window.status === "completed") {
        continue;
      }
      
      // Convert dates properly
      const startDate = typeof window.startDate === 'object' && window.startDate.toDate ? 
                      window.startDate.toDate() : new Date(window.startDate);
      const endDate = typeof window.endDate === 'object' && window.endDate.toDate ? 
                    window.endDate.toDate() : new Date(window.endDate);
      
      // Check if current time is within window
      if (now >= startDate && now <= endDate) {
        console.log(`Current time is within window dates: Week ${window.weekNumber}`);
        return { 
          isActive: true, 
          window: {
            ...window,
            startDate,
            endDate
          }
        };
      }
    }
    
    // No active window found
    console.log("No active transfer window found");
    
    // Find next upcoming window for display
    let nextWindow = null;
    
    for (const window of transferWindows) {
      if (window.status === "completed") continue;
      
      const startDate = typeof window.startDate === 'object' && window.startDate.toDate ? 
                      window.startDate.toDate() : new Date(window.startDate);
      
      if (startDate > now && (!nextWindow || startDate < nextWindow.startDate)) {
        nextWindow = {
          ...window,
          startDate,
          endDate: typeof window.endDate === 'object' && window.endDate.toDate ? 
                 window.endDate.toDate() : new Date(window.endDate)
        };
      }
    }
    
    return { isActive: false, window: nextWindow };
  } catch (error) {
    console.error('Error checking transfer window:', error);
    throw error;
  }
}

// Add to transferService.js
static async updateUserTeamPoints(tournamentId) {
  try {
    // Get all user teams for this tournament
    const userTeamsRef = collection(db, 'userTeams');
    const q = query(userTeamsRef, where('tournamentId', '==', tournamentId));
    const snapshot = await getDocs(q);
    
    const updatePromises = [];
    
    snapshot.forEach(doc => {
      const userTeam = doc.data();
      const userTeamRef = doc.ref;
      const playerPromises = [];
      
      // For each player in the team, get the latest stats
      userTeam.players.forEach(player => {
        const playerPromise = PlayerMasterService.findPlayerByAnyId(player.id)
          .then(masterPlayer => {
            if (masterPlayer) {
              // Update player points from master record
              player.points = masterPlayer.stats?.points || 0;
            }
            return player;
          })
          .catch(error => {
            console.error(`Error updating player ${player.id}:`, error);
            return player; // Return original player on error
          });
        
        playerPromises.push(playerPromise);
      });
      
      // Update the user team with refreshed player data
      const teamPromise = Promise.all(playerPromises)
        .then(updatedPlayers => {
          return updateDoc(userTeamRef, {
            players: updatedPlayers,
            lastUpdated: new Date()
          });
        });
      
      updatePromises.push(teamPromise);
    });
    
    await Promise.all(updatePromises);
    return { success: true, message: 'User teams updated with latest player points' };
  } catch (error) {
    console.error('Error updating user team points:', error);
    throw error;
  }
}

static async updateUserWeeklyStats(matchId) {
  try {
    console.log(`Starting weekly stats update for match ${matchId}`);
    
    // First try to get the week number from the explicit mapping
    const matchWeekRef = doc(db, 'matchWeeks', matchId);
    const matchWeekDoc = await getDoc(matchWeekRef);
    
    let weekNumber;
    let tournamentId;
    
    // If we have an explicit mapping, use it
    if (matchWeekDoc.exists()) {
      weekNumber = matchWeekDoc.data().weekNumber;
      tournamentId = matchWeekDoc.data().tournamentId;
      console.log(`Found explicit mapping: Match ${matchId} belongs to Week ${weekNumber} of tournament ${tournamentId}`);
    } else {
      // Otherwise, fall back to calculating based on date
      // Get match data
      const matchRef = doc(db, 'matches', matchId);
      const matchDoc = await getDoc(matchRef);
      if (!matchDoc.exists()) {
        throw new Error(`Match ${matchId} not found`);
      }
      
      const matchData = matchDoc.data();
      const matchDate = matchData.matchInfo?.startDate || 
                         matchData.matchHeader?.matchStartTimestamp || 
                         new Date();
      
      // Get active tournament
      const tournament = await this.getActiveTournament();
      if (!tournament) {
        console.warn('No active tournament found');
        return { success: false, error: 'No active tournament found' };
      }
      
      tournamentId = tournament.id;
      
      // Find which week this match belongs to
      weekNumber = this.findMatchWeek(matchDate, tournament.transferWindows);
      if (!weekNumber) {
        console.warn(`Could not determine week for match ${matchId}`);
        return { success: false, error: 'Could not determine week' };
      }
      
      console.log(`Calculated match ${matchId} belongs to Week ${weekNumber} of tournament ${tournamentId}`);
      
      // IMPORTANT: Store this mapping for future use
      try {
        await setDoc(matchWeekRef, {
          matchId,
          tournamentId,
          weekNumber,
          autoAssigned: true,
          assignedAt: new Date()
        });
        console.log(`Created match week mapping for match ${matchId}`);
      } catch (mappingError) {
        console.error('Error creating match week mapping:', mappingError);
        // Continue anyway - this is not critical
      }
    }
    
    // Get all user teams for this tournament
    const userTeamsRef = collection(db, 'userTeams');
    const userTeamsQuery = query(userTeamsRef, where('tournamentId', '==', tournamentId));
    const teamsSnapshot = await getDocs(userTeamsQuery);
    
    console.log(`Processing ${teamsSnapshot.size} user teams for tournament ${tournamentId}`);
    
    // Process each user team
    const updatePromises = [];
    teamsSnapshot.forEach(teamDoc => {
      const team = teamDoc.data();
      const userId = team.userId;
      const players = team.players || [];
      
      updatePromises.push(
        this.calculateAndUpdateUserPoints(userId, players, matchId, tournamentId, weekNumber)
      );
    });
    
    await Promise.all(updatePromises);
    console.log(`Successfully updated weekly stats for ${updatePromises.length} users`);
    
    // IMPORTANT: Update weekly rankings after processing all users
    try {
      await this.updateWeeklyRankings(tournamentId, weekNumber);
      console.log(`Updated weekly rankings for tournament ${tournamentId}, week ${weekNumber}`);
      
      // Also update overall rankings
      await this.updateOverallRankings(tournamentId);
      console.log(`Updated overall rankings for tournament ${tournamentId}`);
    } catch (rankingError) {
      console.error('Error updating rankings:', rankingError);
    }
    
    return { success: true };
  } catch (error) {
    console.error('Error updating user weekly stats:', error);
    throw error;
  }
}


static findMatchWeek(matchDate, transferWindows) {
  if (!matchDate || !transferWindows || transferWindows.length === 0) {
    console.log("Missing data to determine match week - defaulting to week 1");
    return 1;
  }

  // Convert matchDate to a proper Date object if it's not already
  const matchDateObj = matchDate instanceof Date ? 
    matchDate : 
    (matchDate.toDate ? matchDate.toDate() : new Date(matchDate));
  
  console.log(`Finding week for match date: ${matchDateObj.toISOString()}`);
  
  // Sort transfer windows by week number for reliable fallback
  const sortedWindows = [...transferWindows].sort((a, b) => a.weekNumber - b.weekNumber);
  
  // Default to first week if all else fails
  const defaultWeek = sortedWindows[0]?.weekNumber || 1;
  
  // Find the transfer window that includes this match date
  for (const window of sortedWindows) {
    try {
      // Handle different date formats
      const startDate = window.startDate instanceof Date ? 
        window.startDate : 
        (window.startDate.toDate ? window.startDate.toDate() : new Date(window.startDate));
      
      const endDate = window.endDate instanceof Date ? 
        window.endDate : 
        (window.endDate.toDate ? window.endDate.toDate() : new Date(window.endDate));
      
      if (matchDateObj >= startDate && matchDateObj <= endDate) {
        return window.weekNumber;
      }
    } catch (error) {
      console.error(`Error processing window ${window.weekNumber}:`, error);
      continue;
    }
  }
  
  // If we can't find a perfect match, return the default
  return defaultWeek;
}

// In src/app/services/transferService.js
// Modify the calculateAndUpdateUserPoints function

static async calculateAndUpdateUserPoints(userId, players, matchId, tournamentId, weekNumber) {
  try {
    // Initialize total points for this match
    let totalPoints = 0;
    let pointsBreakdown = [];
    
    // Define multipliers directly here instead of using this.POINTS
    const CAPTAIN_MULTIPLIER = 2;
    const VICE_CAPTAIN_MULTIPLIER = 1.5;
    
    // Process every player in the team, not just those with match points
    for (let i = 0; i < players.length; i++) {
      const player = players[i];
      const playerId = player.id;
      let playerPoints = 0;
      let isCaptain = player.isCaptain || false;
      let isViceCaptain = player.isViceCaptain || false;
      let basePoints = 0;
      let finalPoints = 0;
      
      // Try to get match points for this player
      try {
        const pointsRef = doc(db, 'playerPoints', `${playerId}_${matchId}`);
        const pointsDoc = await getDoc(pointsRef);
        
        if (pointsDoc.exists()) {
          // Player has points for this match
          basePoints = pointsDoc.data().points || 0;
          
          // Apply captain/vice-captain multipliers
          if (isCaptain) {
            finalPoints = basePoints * CAPTAIN_MULTIPLIER;
          } else if (isViceCaptain) {
            finalPoints = basePoints * VICE_CAPTAIN_MULTIPLIER;
          } else {
            finalPoints = basePoints;
          }
          
          playerPoints = finalPoints;
        } else {
          // Player doesn't have points for this match
          basePoints = 0;
          finalPoints = 0;
        }
      } catch (error) {
        console.error(`Error getting points for player ${playerId}:`, error);
        basePoints = 0;
        finalPoints = 0;
      }
      
      // Add to total team points
      totalPoints += playerPoints;
      
      // Add to points breakdown array
      pointsBreakdown.push({
        playerId: playerId,
        playerName: player.name || 'Unknown',
        basePoints: basePoints,
        finalPoints: finalPoints,
        isCaptain: isCaptain,
        isViceCaptain: isViceCaptain,
        multiplier: isCaptain ? CAPTAIN_MULTIPLIER : 
                   isViceCaptain ? VICE_CAPTAIN_MULTIPLIER : 1
      });
    }
    
    // Update user's weekly stats
    const weeklyStatsRef = doc(db, 'userWeeklyStats', `${userId}_${tournamentId}_${weekNumber}`);
    const weeklyStatsDoc = await getDoc(weeklyStatsRef);
    
    if (weeklyStatsDoc.exists()) {
      // Update existing stats
      const currentData = weeklyStatsDoc.data();
      const currentPoints = currentData.points || 0;
      const existingMatches = currentData.processedMatches || [];
      
      // Only add points if this match hasn't been processed yet
      if (!existingMatches.includes(matchId)) {
        await updateDoc(weeklyStatsRef, {
          points: currentPoints + totalPoints,
          pointsBreakdown: pointsBreakdown, // Store the complete breakdown
          processedMatches: [...existingMatches, matchId],
          updatedAt: new Date()
        });
      }
    } else {
      // Create new stats entry
      await setDoc(weeklyStatsRef, {
        userId,
        tournamentId,
        weekNumber,
        points: totalPoints,
        pointsBreakdown: pointsBreakdown,
        processedMatches: [matchId],
        rank: 0,
        transferWindowId: `${weekNumber}`,
        createdAt: new Date()
      });
    }
    
    return { success: true, points: totalPoints };
  } catch (error) {
    console.error(`Error calculating points for user ${userId}:`, error);
    return { success: false, error: error.message };
  }
}
  
  // Get user's team for a tournament
  static async getUserTeam(userId, tournamentId) {
    try {
      const teamRef = doc(db, 'userTeams', `${userId}_${tournamentId}`);
      const teamDoc = await getDoc(teamRef);
      
      if (!teamDoc.exists()) {
        return null;
      }
      
      return teamDoc.data();
    } catch (error) {
      console.error('Error getting user team:', error);
      throw error;
    }
  }

// Add to src/app/services/transferService.js
static async getUserWeeklyStats(userId) {
  try {
    const tournament = await this.getActiveTournament();
    
    if (!tournament) {
      return [];
    }
    
    // Modify this query to get ALL weekly stats, not just those from active windows
    const weeklyStatsRef = collection(db, 'userWeeklyStats');
    const q = query(
      weeklyStatsRef, 
      where('userId', '==', userId),
      where('tournamentId', '==', tournament.id),
      orderBy('weekNumber', 'desc')
    );
    
    const snapshot = await getDocs(q);
    
    const weeklyStats = [];
    snapshot.forEach(doc => {
      weeklyStats.push({
        id: doc.id,
        ...doc.data()
      });
    });
    
    return weeklyStats;
  } catch (error) {
    console.error('Error getting user weekly stats:', error);
    throw error;
  }
}
// Add to src/app/services/transferService.js
// This function should run on a schedule (via cron job) or when matches are processed

static async ensureWeeklyStatsForAllUsers(tournamentId) {
  try {
    // Get active tournament
    const tournament = await this.getActiveTournament();
    if (!tournament) return { success: false, error: 'No active tournament found' };
    
    // Get all users with teams
    const userTeamsRef = collection(db, 'userTeams');
    const q = query(userTeamsRef, where('tournamentId', '==', tournamentId));
    const snapshot = await getDocs(q);
    
    const promises = [];
    snapshot.forEach(doc => {
      const userData = doc.data();
      // Get current week number or latest window
      const currentWindow = tournament.transferWindows.find(w => w.status === 'active') || 
        tournament.transferWindows.sort((a, b) => b.weekNumber - a.weekNumber)[0];
      
      if (currentWindow) {
        promises.push(
          this.createWeeklyStatsEntry(userData.userId, tournament.id, currentWindow)
        );
      }
    });
    
    await Promise.all(promises);
    return { success: true };
  } catch (error) {
    console.error('Error ensuring weekly stats:', error);
    throw error;
  }
}
  
  // Get all available players
  static async getAvailablePlayers() {
    try {
      const playersRef = collection(db, 'playersMaster');
      const q = query(playersRef, where('active', '==', true));
      const snapshot = await getDocs(q);
      
      const players = {
        batsmen: [],
        bowlers: [],
        allrounders: [],
        wicketkeepers: []
      };
      
      snapshot.forEach(doc => {
        const player = {
          id: doc.id,
          ...doc.data()
        };
        
        // Add to appropriate category
        if (player.role === this.ROLES.BATSMAN) {
          players.batsmen.push(player);
        } else if (player.role === this.ROLES.BOWLER) {
          players.bowlers.push(player);
        } else if (player.role === this.ROLES.ALLROUNDER) {
          players.allrounders.push(player);
        } else if (player.role === this.ROLES.WICKETKEEPER) {
          players.wicketkeepers.push(player);
        }
      });
      
      // Sort by points
      const sortByPoints = (a, b) => {
        const pointsA = a.stats?.points || 0;
        const pointsB = b.stats?.points || 0;
        return pointsB - pointsA;
      };
      
      players.batsmen.sort(sortByPoints);
      players.bowlers.sort(sortByPoints);
      players.allrounders.sort(sortByPoints);
      players.wicketkeepers.sort(sortByPoints);
      
      return players;
    } catch (error) {
      console.error('Error getting available players:', error);
      throw error;
    }
  }
  
  // Save user team
  static async saveUserTeam(userId, players) {
    try {
      const tournament = await this.getActiveTournament();
      
      if (!tournament) {
        return { success: false, error: 'No active tournament found' };
      }
      
      const { isActive } = await this.isTransferWindowActive();
      
      if (!isActive) {
        return { success: false, error: 'Transfer window is not active' };
      }
      
      // Validate team composition - FIX HERE
    const batsmenCount = players.filter(p => p.role === this.ROLES.BATSMAN).length;
    const bowlersCount = players.filter(p => p.role === this.ROLES.BOWLER).length;
    const allroundersCount = players.filter(p => p.role === this.ROLES.ALLROUNDER).length;
    const wicketkeepersCount = players.filter(p => p.role === this.ROLES.WICKETKEEPER).length;
    
    // Check each role count explicitly
    if (batsmenCount !== this.TEAM_LIMITS[this.ROLES.BATSMAN]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.BATSMAN]} batsmen` };
    }
    
    if (bowlersCount !== this.TEAM_LIMITS[this.ROLES.BOWLER]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.BOWLER]} bowlers` };
    }
    
    if (allroundersCount !== this.TEAM_LIMITS[this.ROLES.ALLROUNDER]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.ALLROUNDER]} all-rounders` };
    }
    
    if (wicketkeepersCount !== this.TEAM_LIMITS[this.ROLES.WICKETKEEPER]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.WICKETKEEPER]} wicket-keeper` };
    }
      
      // Check if team exists
      const userTeam = await this.getUserTeam(userId, tournament.id);
      
      // Determine if this is a new team or update
      const isNewTeam = !userTeam;
      
      // Find current transfer window
      const now = new Date();
      const currentWindow = tournament.transferWindows.find(window => {
        const startDate = window.startDate instanceof Timestamp 
          ? window.startDate.toDate() 
          : new Date(window.startDate);
        const endDate = window.endDate instanceof Timestamp 
          ? window.endDate.toDate() 
          : new Date(window.endDate);
        
        return now >= startDate && now <= endDate;
      });
      
      // Create/update team document
      const teamRef = doc(db, 'userTeams', `${userId}_${tournament.id}`);
      await setDoc(teamRef, {
        userId,
        tournamentId: tournament.id,
        registrationDate: isNewTeam ? now : userTeam.registrationDate,
        isLateRegistration: isNewTeam ? now > new Date(tournament.registrationDeadline) : userTeam.isLateRegistration,
        players,
        transfersRemaining: isNewTeam ? 2 : userTeam.transfersRemaining - 1,
        lastTransferDate: now,
        lastTransferWindow: currentWindow ? {
          startDate: currentWindow.startDate,
          endDate: currentWindow.endDate,
          weekNumber: currentWindow.weekNumber
        } : null,
        lastUpdated: now
      }, { merge: true });
      
      // Create weekly stats entry if needed
      if (currentWindow) {
        await this.createWeeklyStatsEntry(userId, tournament.id, currentWindow);
      }
      
      return { success: true };
    } catch (error) {
      console.error('Error saving user team:', error);
      throw error;
    }
  }
  
  // Create or update weekly stats entry
  static async createWeeklyStatsEntry(userId, tournamentId, transferWindow) {
    try {
      const weeklyStatsRef = doc(db, 'userWeeklyStats', `${userId}_${tournamentId}_${transferWindow.weekNumber}`);
      const weeklyStatsDoc = await getDoc(weeklyStatsRef);
      
      if (!weeklyStatsDoc.exists()) {
        // Create new weekly stats entry
        await setDoc(weeklyStatsRef, {
          userId,
          tournamentId,
          weekNumber: transferWindow.weekNumber,
          transferWindowId: `${transferWindow.weekNumber}`,
          points: 0,
          rank: 0,
          createdAt: new Date()
        });
      }
      
      return { success: true };
    } catch (error) {
      console.error('Error creating weekly stats entry:', error);
      throw error;
    }
  }
  
  // Get user's weekly stats
  static async getUserWeeklyStats(userId) {
    try {
      const tournament = await this.getActiveTournament();
      
      if (!tournament) {
        return [];
      }
      
      const weeklyStatsRef = collection(db, 'userWeeklyStats');
      const q = query(
        weeklyStatsRef, 
        where('userId', '==', userId),
        where('tournamentId', '==', tournament.id),
        orderBy('weekNumber', 'desc')
      );
      
      const snapshot = await getDocs(q);
      
      const weeklyStats = [];
      snapshot.forEach(doc => {
        weeklyStats.push({
          id: doc.id,
          ...doc.data()
        });
      });
      
      return weeklyStats;
    } catch (error) {
      console.error('Error getting user weekly stats:', error);
      throw error;
    }
  }

static async updateWeeklyRankings(tournamentId, weekNumber) {
  try {
    console.log(`Updating rankings for tournament ${tournamentId}, week ${weekNumber}`);
    
    // Get all weekly stats for this tournament and week
    const statsRef = collection(db, 'userWeeklyStats');
    const q = query(
      statsRef, 
      where('tournamentId', '==', tournamentId),
      where('weekNumber', '==', weekNumber)
    );
    
    const snapshot = await getDocs(q);
    
    // Sort users by points (highest first)
    const userStats = [];
    snapshot.forEach(doc => {
      userStats.push({
        id: doc.id,
        userId: doc.data().userId,
        points: doc.data().points || 0
      });
    });
    
    // Sort by points (descending)
    userStats.sort((a, b) => b.points - a.points);
    
    // Update ranks
    const updatePromises = [];
    let currentRank = 1;
    let previousPoints = null;
    
    userStats.forEach((stat, index) => {
      // If points are the same as previous user, assign the same rank
      // Otherwise, assign rank based on position
      if (previousPoints !== null && stat.points !== previousPoints) {
        currentRank = index + 1;
      }
      
      previousPoints = stat.points;
      
      // Update the document with the rank
      const statRef = doc(db, 'userWeeklyStats', stat.id);
      updatePromises.push(
        updateDoc(statRef, { rank: currentRank })
      );
    });
    
    await Promise.all(updatePromises);
    console.log(`Updated ranks for ${updatePromises.length} users`);
    
    return { success: true };
  } catch (error) {
    console.error('Error updating weekly rankings:', error);
    throw error;
  }
}

static async updateOverallRankings(tournamentId) {
  try {
    // Get all users with teams in this tournament
    const userTeamsRef = collection(db, 'userTeams');
    const teamsQuery = query(userTeamsRef, where('tournamentId', '==', tournamentId));
    const teamsSnapshot = await getDocs(teamsQuery);
    
    // Calculate total points for each user
    const userStats = [];
    
    for (const teamDoc of teamsSnapshot.docs) {
      const userId = teamDoc.data().userId;
      
      // Get all weekly stats for this user
      const statsRef = collection(db, 'userWeeklyStats');
      const statsQuery = query(
        statsRef,
        where('userId', '==', userId),
        where('tournamentId', '==', tournamentId)
      );
      
      const statsSnapshot = await getDocs(statsQuery);
      
      // Sum up points across all weeks
      let totalPoints = 0;
      statsSnapshot.forEach(doc => {
        totalPoints += doc.data().points || 0;
      });
      
      userStats.push({
        userId,
        totalPoints
      });
    }
    
    // Sort by total points (descending)
    userStats.sort((a, b) => b.totalPoints - a.totalPoints);
    
    // Update user ranks
    const updatePromises = [];
    let currentRank = 1;
    let previousPoints = null;
    
    userStats.forEach((stat, index) => {
      // If points are the same as previous user, assign the same rank
      if (previousPoints !== null && stat.totalPoints !== previousPoints) {
        currentRank = index + 1;
      }
      
      previousPoints = stat.totalPoints;
      
      // Update the user document with overall rank and total points
      const userRef = doc(db, 'users', stat.userId);
      updatePromises.push(
        updateDoc(userRef, { 
          rank: currentRank,
          totalPoints: stat.totalPoints
        })
      );
    });
    
    await Promise.all(updatePromises);
    console.log(`Updated overall ranks for ${updatePromises.length} users`);
    
    return { success: true };
  } catch (error) {
    console.error('Error updating overall rankings:', error);
    throw error;
  }
}
  
  // Process referral
static async processReferral(referredUserId, referrerCode) {
  try {
    if (!referrerCode) {
      return { success: false, error: 'No referral code provided' };
    }
    
    console.log(`Processing referral code ${referrerCode} for user ${referredUserId}`);
    
    // First check if user has already been referred
    const referredUserRef = doc(db, 'users', referredUserId);
    const referredUserDoc = await getDoc(referredUserRef);
    
    if (referredUserDoc.exists() && referredUserDoc.data().referredBy) {
      console.log('User has already used a referral code');
      return { success: false, error: 'You have already used a referral code' };
    }
    
    // Find user with this referral code
    const usersRef = collection(db, 'users');
    const q = query(usersRef, where('referralCode', '==', referrerCode));
    const snapshot = await getDocs(q);
    
    if (snapshot.empty) {
      console.log('No user found with the provided referral code');
      return { success: false, error: 'Invalid referral code - no matching user found' };
    }
    
    const referrerDoc = snapshot.docs[0];
    const referrerId = referrerDoc.id;
    const referrerData = referrerDoc.data();
    
    console.log(`Found referrer: ${referrerId}`);
    
    // Ensure user is not referring themselves
    if (referrerId === referredUserId) {
      console.log('User attempting to refer themselves');
      return { success: false, error: 'You cannot refer yourself' };
    }
    
    // Check if referrer already has max referrals
    const referrals = referrerData.referrals || [];
    const maxReferrals = 3; // Max referrals allowed
    
    if (referrals.length >= maxReferrals) {
      console.log('Referrer has reached maximum number of referrals');
      
      // Still track the referral but don't award points
      await updateDoc(doc(db, 'users', referrerId), {
        referrals: arrayUnion(referredUserId)
      });
      
      // Update referred user document
      await updateDoc(doc(db, 'users', referredUserId), {
        referredBy: referrerId
      });
      
      return { 
        success: true,
        referrerId,
        message: 'Referral recorded, but referrer has reached maximum bonus points'
      };
    }
    
    // If we get here, the referral is valid and points should be awarded
    console.log('Awarding referral points');
    
    // Calculate points to award (can be configured elsewhere)
    const referralPoints = 25;
    
    // Update referrer document with new referral and points
    await updateDoc(doc(db, 'users', referrerId), {
      referrals: arrayUnion(referredUserId),
      referralPoints: increment(referralPoints),
      totalPoints: increment(referralPoints)
    });
    
    // Update referred user document
    await updateDoc(doc(db, 'users', referredUserId), {
      referredBy: referrerId
    });
    
    console.log(`Successfully processed referral. ${referralPoints} points awarded to ${referrerId}`);
    
    return { 
      success: true,
      referrerId,
      pointsAwarded: referralPoints
    };
  } catch (error) {
    console.error('Error processing referral:', error);
    throw error;
  }
}
}

export default transferService;
