import { db } from '../../firebase';
import { 
  doc, 
  getDoc, 
  setDoc, 
  collection, 
  query, 
  where, 
  getDocs, 
  orderBy, 
  limit, 
  Timestamp,
  updateDoc,
  increment,
  arrayUnion
} from 'firebase/firestore';

export class transferService {
  static ROLES = {
    BATSMAN: 'batsman',
    BOWLER: 'bowler',
    ALLROUNDER: 'allrounder',
    WICKETKEEPER: 'wicketkeeper'
  };
  
  static TEAM_LIMITS = {
    [this.ROLES.BATSMAN]: 4,
    [this.ROLES.BOWLER]: 4,
    [this.ROLES.ALLROUNDER]: 2,
    [this.ROLES.WICKETKEEPER]: 1
  };
  
  // Get active tournament
static async getActiveTournament() {
  try {
    console.log("Getting active tournament...");
    const tournamentsRef = collection(db, 'tournaments');
    
    // Query for tournaments with status 'active'
    const q = query(tournamentsRef, where('status', '==', 'active'), limit(1));
    const snapshot = await getDocs(q);
    
    if (snapshot.empty) {
      console.log("No tournament with 'active' status found");
      // Fallback to getting the most recent tournament
      const allQuery = query(tournamentsRef, orderBy('createdAt', 'desc'), limit(1));
      const allSnapshot = await getDocs(allQuery);
      
      if (allSnapshot.empty) {
        console.log("No tournaments found at all");
        return null;
      }
      
      const tournamentData = allSnapshot.docs[0].data();
      const tournamentId = allSnapshot.docs[0].id;
      console.log(`Found most recent tournament: ${tournamentId}`);
      
      return {
        id: tournamentId,
        ...tournamentData
      };
    }
    
    const tournamentData = snapshot.docs[0].data();
    const tournamentId = snapshot.docs[0].id;
    console.log(`Found active tournament: ${tournamentId}`);
    
    return {
      id: tournamentId,
      ...tournamentData
    };
  } catch (error) {
    console.error('Error getting active tournament:', error);
    throw error;
  }
}

// Replace or update your isTransferWindowActive function with this implementation
static async isTransferWindowActive() {
  try {
    const tournament = await this.getActiveTournament();
    
    if (!tournament) {
      console.log("No active tournament found");
      return { isActive: false, window: null };
    }
    
    // If tournament itself is completed, no windows should be active
    if (tournament.status === "completed") {
      console.log("Tournament is completed, no active windows");
      return { isActive: false, window: null };
    }
    
    const transferWindows = tournament.transferWindows || [];
    
    // First look for a window explicitly marked as active
    for (const window of transferWindows) {
      if (window.status === "active") {
        // Format dates for return
        const startDate = typeof window.startDate === 'object' && window.startDate.toDate ? 
                        window.startDate.toDate() : new Date(window.startDate);
        const endDate = typeof window.endDate === 'object' && window.endDate.toDate ? 
                      window.endDate.toDate() : new Date(window.endDate);
        
        // Log for debugging
        console.log(`Found explicitly active window: Week ${window.weekNumber}`);
        
        return { 
          isActive: true, 
          window: {
            ...window,
            startDate,
            endDate
          }
        };
      }
    }
    
    // No explicitly active window, check dates
    const now = new Date();
    
    for (const window of transferWindows) {
      // Skip completed windows
      if (window.status === "completed") {
        continue;
      }
      
      // Convert dates properly
      const startDate = typeof window.startDate === 'object' && window.startDate.toDate ? 
                      window.startDate.toDate() : new Date(window.startDate);
      const endDate = typeof window.endDate === 'object' && window.endDate.toDate ? 
                    window.endDate.toDate() : new Date(window.endDate);
      
      // Check if current time is within window
      if (now >= startDate && now <= endDate) {
        console.log(`Current time is within window dates: Week ${window.weekNumber}`);
        return { 
          isActive: true, 
          window: {
            ...window,
            startDate,
            endDate
          }
        };
      }
    }
    
    // No active window found
    console.log("No active transfer window found");
    
    // Find next upcoming window for display
    let nextWindow = null;
    
    for (const window of transferWindows) {
      if (window.status === "completed") continue;
      
      const startDate = typeof window.startDate === 'object' && window.startDate.toDate ? 
                      window.startDate.toDate() : new Date(window.startDate);
      
      if (startDate > now && (!nextWindow || startDate < nextWindow.startDate)) {
        nextWindow = {
          ...window,
          startDate,
          endDate: typeof window.endDate === 'object' && window.endDate.toDate ? 
                 window.endDate.toDate() : new Date(window.endDate)
        };
      }
    }
    
    return { isActive: false, window: nextWindow };
  } catch (error) {
    console.error('Error checking transfer window:', error);
    throw error;
  }
}

static async updateUserWeeklyStats(matchId) {
  try {
    // Get all user teams
    const userTeamsRef = collection(db, 'userTeams');
    const teamsSnapshot = await getDocs(userTeamsRef);
    
    // Get match data to determine week number
    const matchRef = doc(db, 'matches', matchId);
    const matchDoc = await getDoc(matchRef);
    if (!matchDoc.exists()) {
      throw new Error(`Match ${matchId} not found`);
    }
    
    const matchData = matchDoc.data();
    const matchDate = matchData.matchInfo?.startDate || new Date();
    
    // Get active tournament
    const tournament = await this.getActiveTournament();
    if (!tournament) {
      console.warn('No active tournament found');
      return;
    }
    
    // Find which week this match belongs to
    const matchWeek = this.findMatchWeek(matchDate, tournament.transferWindows);
    if (!matchWeek) {
      console.warn(`Could not determine week for match ${matchId}`);
      return;
    }
    
    // Process each user team
    const updatePromises = [];
    teamsSnapshot.forEach(teamDoc => {
      const team = teamDoc.data();
      const userId = team.userId;
      const players = team.players || [];
      
      updatePromises.push(
        this.calculateAndUpdateUserPoints(userId, players, matchId, tournament.id, matchWeek)
      );
    });
    
    await Promise.all(updatePromises);
    return { success: true };
  } catch (error) {
    console.error('Error updating user weekly stats:', error);
    throw error;
  }
}

static findMatchWeek(matchDate, transferWindows) {
  // Find the transfer window that includes this match date
  for (const window of transferWindows) {
    const startDate = window.startDate instanceof Timestamp 
      ? window.startDate.toDate() 
      : new Date(window.startDate);
    const endDate = window.endDate instanceof Timestamp 
      ? window.endDate.toDate() 
      : new Date(window.endDate);
    
    if (matchDate >= startDate && matchDate <= endDate) {
      return window.weekNumber;
    }
  }
  
  // If no exact match, use the closest window before the match
  let closestWindow = null;
  let smallestDiff = Number.MAX_SAFE_INTEGER;
  
  for (const window of transferWindows) {
    const endDate = window.endDate instanceof Timestamp 
      ? window.endDate.toDate() 
      : new Date(window.endDate);
    
    if (endDate <= matchDate) {
      const diff = matchDate - endDate;
      if (diff < smallestDiff) {
        smallestDiff = diff;
        closestWindow = window;
      }
    }
  }
  
  return closestWindow ? closestWindow.weekNumber : null;
}

static async calculateAndUpdateUserPoints(userId, players, matchId, tournamentId, weekNumber) {
  try {
    // Initialize total points for this match
    let totalPoints = 0;
    
    // Get match points for each player
    for (const player of players) {
      // Create player doc ID from name or use existing ID
      const playerId = player.id;
      
      // Check if player has points for this match
      const pointsRef = doc(db, 'playerPoints', `${playerId}_${matchId}`);
      const pointsDoc = await getDoc(pointsRef);
      
      if (pointsDoc.exists()) {
        const playerPoints = pointsDoc.data().points || 0;
        
        // Apply captain/vice-captain multipliers
        let multipliedPoints = playerPoints;
        if (player.isCaptain) {
          multipliedPoints *= 2;
        } else if (player.isViceCaptain) {
          multipliedPoints *= 1.5;
        }
        
        totalPoints += multipliedPoints;
      }
    }
    
    // Update user's weekly stats
    const weeklyStatsRef = doc(db, 'userWeeklyStats', `${userId}_${tournamentId}_${weekNumber}`);
    const weeklyStatsDoc = await getDoc(weeklyStatsRef);
    
    if (weeklyStatsDoc.exists()) {
      // Update existing stats
      const currentPoints = weeklyStatsDoc.data().points || 0;
      await updateDoc(weeklyStatsRef, {
        points: currentPoints + totalPoints,
        updatedAt: new Date()
      });
    } else {
      // Create new stats entry
      await setDoc(weeklyStatsRef, {
        userId,
        tournamentId,
        weekNumber,
        points: totalPoints,
        rank: 0,
        transferWindowId: `${weekNumber}`,
        createdAt: new Date()
      });
    }
    
    return { success: true };
  } catch (error) {
    console.error(`Error calculating points for user ${userId}:`, error);
    return { success: false, error: error.message };
  }
}
  
  // Get user's team for a tournament
  static async getUserTeam(userId, tournamentId) {
    try {
      const teamRef = doc(db, 'userTeams', `${userId}_${tournamentId}`);
      const teamDoc = await getDoc(teamRef);
      
      if (!teamDoc.exists()) {
        return null;
      }
      
      return teamDoc.data();
    } catch (error) {
      console.error('Error getting user team:', error);
      throw error;
    }
  }

// Add to src/app/services/transferService.js
static async getUserWeeklyStats(userId) {
  try {
    const tournament = await this.getActiveTournament();
    
    if (!tournament) {
      return [];
    }
    
    // Modify this query to get ALL weekly stats, not just those from active windows
    const weeklyStatsRef = collection(db, 'userWeeklyStats');
    const q = query(
      weeklyStatsRef, 
      where('userId', '==', userId),
      where('tournamentId', '==', tournament.id),
      orderBy('weekNumber', 'desc')
    );
    
    const snapshot = await getDocs(q);
    
    const weeklyStats = [];
    snapshot.forEach(doc => {
      weeklyStats.push({
        id: doc.id,
        ...doc.data()
      });
    });
    
    return weeklyStats;
  } catch (error) {
    console.error('Error getting user weekly stats:', error);
    throw error;
  }
}
// Add to src/app/services/transferService.js
// This function should run on a schedule (via cron job) or when matches are processed

static async ensureWeeklyStatsForAllUsers(tournamentId) {
  try {
    // Get active tournament
    const tournament = await this.getActiveTournament();
    if (!tournament) return { success: false, error: 'No active tournament found' };
    
    // Get all users with teams
    const userTeamsRef = collection(db, 'userTeams');
    const q = query(userTeamsRef, where('tournamentId', '==', tournamentId));
    const snapshot = await getDocs(q);
    
    const promises = [];
    snapshot.forEach(doc => {
      const userData = doc.data();
      // Get current week number or latest window
      const currentWindow = tournament.transferWindows.find(w => w.status === 'active') || 
        tournament.transferWindows.sort((a, b) => b.weekNumber - a.weekNumber)[0];
      
      if (currentWindow) {
        promises.push(
          this.createWeeklyStatsEntry(userData.userId, tournament.id, currentWindow)
        );
      }
    });
    
    await Promise.all(promises);
    return { success: true };
  } catch (error) {
    console.error('Error ensuring weekly stats:', error);
    throw error;
  }
}
  
  // Get all available players
  static async getAvailablePlayers() {
    try {
      const playersRef = collection(db, 'playersMaster');
      const q = query(playersRef, where('active', '==', true));
      const snapshot = await getDocs(q);
      
      const players = {
        batsmen: [],
        bowlers: [],
        allrounders: [],
        wicketkeepers: []
      };
      
      snapshot.forEach(doc => {
        const player = {
          id: doc.id,
          ...doc.data()
        };
        
        // Add to appropriate category
        if (player.role === this.ROLES.BATSMAN) {
          players.batsmen.push(player);
        } else if (player.role === this.ROLES.BOWLER) {
          players.bowlers.push(player);
        } else if (player.role === this.ROLES.ALLROUNDER) {
          players.allrounders.push(player);
        } else if (player.role === this.ROLES.WICKETKEEPER) {
          players.wicketkeepers.push(player);
        }
      });
      
      // Sort by points
      const sortByPoints = (a, b) => {
        const pointsA = a.stats?.points || 0;
        const pointsB = b.stats?.points || 0;
        return pointsB - pointsA;
      };
      
      players.batsmen.sort(sortByPoints);
      players.bowlers.sort(sortByPoints);
      players.allrounders.sort(sortByPoints);
      players.wicketkeepers.sort(sortByPoints);
      
      return players;
    } catch (error) {
      console.error('Error getting available players:', error);
      throw error;
    }
  }
  
  // Save user team
  static async saveUserTeam(userId, players) {
    try {
      const tournament = await this.getActiveTournament();
      
      if (!tournament) {
        return { success: false, error: 'No active tournament found' };
      }
      
      const { isActive } = await this.isTransferWindowActive();
      
      if (!isActive) {
        return { success: false, error: 'Transfer window is not active' };
      }
      
      // Validate team composition - FIX HERE
    const batsmenCount = players.filter(p => p.role === this.ROLES.BATSMAN).length;
    const bowlersCount = players.filter(p => p.role === this.ROLES.BOWLER).length;
    const allroundersCount = players.filter(p => p.role === this.ROLES.ALLROUNDER).length;
    const wicketkeepersCount = players.filter(p => p.role === this.ROLES.WICKETKEEPER).length;
    
    // Check each role count explicitly
    if (batsmenCount !== this.TEAM_LIMITS[this.ROLES.BATSMAN]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.BATSMAN]} batsmen` };
    }
    
    if (bowlersCount !== this.TEAM_LIMITS[this.ROLES.BOWLER]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.BOWLER]} bowlers` };
    }
    
    if (allroundersCount !== this.TEAM_LIMITS[this.ROLES.ALLROUNDER]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.ALLROUNDER]} all-rounders` };
    }
    
    if (wicketkeepersCount !== this.TEAM_LIMITS[this.ROLES.WICKETKEEPER]) {
      return { success: false, error: `Team must have exactly ${this.TEAM_LIMITS[this.ROLES.WICKETKEEPER]} wicket-keeper` };
    }
      
      // Check if team exists
      const userTeam = await this.getUserTeam(userId, tournament.id);
      
      // Determine if this is a new team or update
      const isNewTeam = !userTeam;
      
      // Find current transfer window
      const now = new Date();
      const currentWindow = tournament.transferWindows.find(window => {
        const startDate = window.startDate instanceof Timestamp 
          ? window.startDate.toDate() 
          : new Date(window.startDate);
        const endDate = window.endDate instanceof Timestamp 
          ? window.endDate.toDate() 
          : new Date(window.endDate);
        
        return now >= startDate && now <= endDate;
      });
      
      // Create/update team document
      const teamRef = doc(db, 'userTeams', `${userId}_${tournament.id}`);
      await setDoc(teamRef, {
        userId,
        tournamentId: tournament.id,
        registrationDate: isNewTeam ? now : userTeam.registrationDate,
        isLateRegistration: isNewTeam ? now > new Date(tournament.registrationDeadline) : userTeam.isLateRegistration,
        players,
        transfersRemaining: isNewTeam ? 2 : userTeam.transfersRemaining - 1,
        lastTransferDate: now,
        lastTransferWindow: currentWindow ? {
          startDate: currentWindow.startDate,
          endDate: currentWindow.endDate,
          weekNumber: currentWindow.weekNumber
        } : null,
        lastUpdated: now
      }, { merge: true });
      
      // Create weekly stats entry if needed
      if (currentWindow) {
        await this.createWeeklyStatsEntry(userId, tournament.id, currentWindow);
      }
      
      return { success: true };
    } catch (error) {
      console.error('Error saving user team:', error);
      throw error;
    }
  }
  
  // Create or update weekly stats entry
  static async createWeeklyStatsEntry(userId, tournamentId, transferWindow) {
    try {
      const weeklyStatsRef = doc(db, 'userWeeklyStats', `${userId}_${tournamentId}_${transferWindow.weekNumber}`);
      const weeklyStatsDoc = await getDoc(weeklyStatsRef);
      
      if (!weeklyStatsDoc.exists()) {
        // Create new weekly stats entry
        await setDoc(weeklyStatsRef, {
          userId,
          tournamentId,
          weekNumber: transferWindow.weekNumber,
          transferWindowId: `${transferWindow.weekNumber}`,
          points: 0,
          rank: 0,
          createdAt: new Date()
        });
      }
      
      return { success: true };
    } catch (error) {
      console.error('Error creating weekly stats entry:', error);
      throw error;
    }
  }
  
  // Get user's weekly stats
  static async getUserWeeklyStats(userId) {
    try {
      const tournament = await this.getActiveTournament();
      
      if (!tournament) {
        return [];
      }
      
      const weeklyStatsRef = collection(db, 'userWeeklyStats');
      const q = query(
        weeklyStatsRef, 
        where('userId', '==', userId),
        where('tournamentId', '==', tournament.id),
        orderBy('weekNumber', 'desc')
      );
      
      const snapshot = await getDocs(q);
      
      const weeklyStats = [];
      snapshot.forEach(doc => {
        weeklyStats.push({
          id: doc.id,
          ...doc.data()
        });
      });
      
      return weeklyStats;
    } catch (error) {
      console.error('Error getting user weekly stats:', error);
      throw error;
    }
  }
  
  // Process referral
  static async processReferral(referredUserId, referrerCode) {
    try {
      if (!referrerCode) {
        return { success: false, error: 'No referral code provided' };
      }
      
      // Find user with this referral code
      const usersRef = collection(db, 'users');
      const q = query(usersRef, where('referralCode', '==', referrerCode));
      const snapshot = await getDocs(q);
      
      if (snapshot.empty) {
        return { success: false, error: 'Invalid referral code' };
      }
      
      const referrerDoc = snapshot.docs[0];
      const referrerId = referrerDoc.id;
      const referrerData = referrerDoc.data();
      
      // Ensure user is not referring themselves
      if (referrerId === referredUserId) {
        return { success: false, error: 'You cannot refer yourself' };
      }
      
      // Check if referrer already has max referrals
      const referrals = referrerData.referrals || [];
      if (referrals.length >= 3) {
        // Still track the referral but don't award points
        await updateDoc(doc(db, 'users', referrerId), {
          referrals: arrayUnion(referredUserId)
        });
        
        return { 
          success: true, 
          message: 'Referral recorded, but referrer has reached maximum bonus points'
        };
      }
      
      // Update referrer document
      await updateDoc(doc(db, 'users', referrerId), {
        referrals: arrayUnion(referredUserId),
        referralPoints: increment(25),
        totalPoints: increment(25)
      });
      
      // Update referred user document
      await updateDoc(doc(db, 'users', referredUserId), {
        referredBy: referrerId
      });
      
      return { success: true };
    } catch (error) {
      console.error('Error processing referral:', error);
      throw error;
    }
  }
}

export default transferService;
